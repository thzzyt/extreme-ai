Directory structure:
└── abacatepay-abacatepay-python-sdk/
    ├── README.md
    ├── README-pt.md
    ├── abacatepay/
    │   ├── __init__.py
    │   ├── constants.py
    │   ├── base/
    │   │   ├── ___init___.py
    │   │   └── client.py
    │   ├── billings/
    │   │   ├── __init__.py
    │   │   ├── client.py
    │   │   └── models.py
    │   ├── coupons/
    │   │   ├── __init__.py
    │   │   ├── client.py
    │   │   └── models.py
    │   ├── customers/
    │   │   ├── __init__.py
    │   │   ├── client.py
    │   │   └── models.py
    │   ├── pixQrCode/
    │   │   ├── __init__.py
    │   │   ├── client.py
    │   │   └── models.py
    │   ├── products/
    │   │   ├── __init__.py
    │   │   └── models.py
    │   └── utils/
    │       ├── exceptions.py
    │       └── helpers.py
    └── tests/
        ├── conftest.py
        ├── integration/
        │   ├── __init__.py
        │   ├── test_auth.py
        │   ├── billings/
        │   │   ├── __init__.py
        │   │   └── test_client.py
        │   └── customers/
        │       ├── __init__.py
        │       ├── conftest.py
        │       └── test_client.py
        └── unit/
            ├── __init__.py
            ├── base/
            │   ├── __init__.py
            │   └── test_client.py
            ├── billings/
            │   └── test_billing_models.py
            ├── coupons/
            │   └── test_coupons_models.py
            ├── customers/
            │   ├── __init__.py
            │   └── test_customers_models.py
            ├── pixQrCode/
            │   └── test_qrcode_models.py
            ├── products/
            │   ├── __init__.py
            │   └── test_products_models.py
            └── utils/
                ├── __init__.py
                └── test_helpers.py

================================================
FILE: README.md
================================================
# AbacatePay SDK

![PyPI Version](https://img.shields.io/pypi/v/abacatepay?label=pypi%20package)
![PyPI Downloads](https://img.shields.io/pypi/dm/abacatepay)

> A Python SDK to simplify interactions with the AbacatePay API. <br />
> This SDK provides tools for billing management, customer handling, and more.


[English](README.md) | [Português](README-pt.md)

---

## Table of Contents

- [Installation](#installation)
- [Getting Started](#getting-started)
- [Usage Examples](#usage-examples)
  - [Create a Billing](#create-a-billing)
  - [List All Billings](#list-all-billings)
  - [Customer Management](#customer-management)
- [Contributing](#contributing)

---

## Installation

### Using pip

```bash
pip install abacatepay
```

### Using Poetry

```bash
poetry add abacatepay
```

---

## Getting Started

To use the SDK, import it and initialize the client with your API key:

```python
import abacatepay

client = abacatepay.AbacatePay("<your-api-key>")
```

---

## Usage Examples

### Create a Billing

```python
from abacatepay.products import Product


products = [
    Product(
        external_id="123",
        name="Test Product",
        quantity=1,
        price=50_00,
        description="Example product"
    ),
    # or as dict
    {
        'external_id': "321",
        'name': "Product as dict",
        'quantity': 1,
        'price': 10_00,
        'description': "Example using dict"
    }
]

billing = client.billing.create(
    products=products,
    return_url="https://yourwebsite.com/return",
    completion_url="https://yourwebsite.com/complete"
)

print(billing.data.url)
```

### List All Billings

```python
billings = client.billing.list()
for billing in billings:
    print(billing.id, billing.status)

print(len(billings))
```

### Customer Management

```python
from abacatepay.customers import CustomerMetadata

customer = CustomerMetadata(  # Its can also be only a dict
    email="customer@example.com",
    name="Customer Name",
    cellphone="(12) 3456-7890",
    tax_id="123-456-789-10"
)

created_customer = client.customers.create(customer)
print(created_customer.id)
```

---

## Contributing

We welcome contributions to the AbacatePay SDK! Follow the steps below to get started:

1. Fork the repository on GitHub.

2. Clone your fork locally:

   ```bash
   git clone https://github.com/your-username/abacatepay.git
   cd abacatepay
   ```

3. Set up the virtual environment using [poetry](https://python-poetry.org/):
> If you don't have poetry installed, you can install following the instructions [here](https://python-poetry.org/docs/#installing-with-the-official-installer).

   ```bash
   poetry install
   ```

4. Make your changes in a new branch:

   ```bash
   git checkout -b feature-name
   ```

5. Run tests to ensure your changes don’t break existing functionality:

   ```bash
   poetry run pytest
   ```

6. Commit your changes and push the branch:

   ```bash
   git add .
   git commit -m "Add feature or fix description"
   git push origin feature-name
   ```

7. Open a pull request on GitHub and describe your changes.



================================================
FILE: README-pt.md
================================================
# AbacatePay SDK

![PyPI Version](https://img.shields.io/pypi/v/abacatepay?label=pypi%20package)
![PyPI Downloads](https://img.shields.io/pypi/dm/abacatepay)

> Um SDK Python para simplificar a interação com a API do AbacatePay. <br />
> Esse SDK fornece ferramentas para gerenciamento de faturamento, gerenciamento de clientes e muito mais.

[Inglês](README.md) | [Português](README-pt.md)

---

## Índice

- [Instalação](#instalação)
- [Iniciando](#iniciando)
- [Exemplos de Uso](#exemplos-de-uso)
  - [Criar uma fatura](#criar-uma-fatura)
  - [Listar todas as faturas](#listar-todas-as-faturas)
  - [Gerenciamento de clientes](#gerenciamento-de-clientes)
- [Contribuindo](#contribuindo)

---

## Instalação

### Usando pip

```bash
pip install abacatepay
```

### Usando Poetry

```bash
poetry add abacatepay
```

---

## Iniciando

Para usar o SDK, importe-o e inicialize o cliente com sua chave de API:

```python
import abacatepay

client = abacatepay.AbacatePay("<your-api-key>")
```

---

## Exemplos de Uso

### Criar uma fatura

```python
from abacatepay.products import Product

products = [
    Product(
        external_id="123",
        name="Test Product",
        quantity=1,
        price=5000,
        description="Example product"
    ),
    # ou como um dicionário
    {
        'external_id': "321",
        'name': "Product as dict",
        'quantity': 1,
        'price': 10_00,
        'description': "Example using dict"
    }
]

billing = client.billing.create(
    products=products,
    return_url="https://yourwebsite.com/return",
    completion_url="https://yourwebsite.com/complete"
)

print(billing.data.url)
```

### Listar todas as faturas

```python
billings = client.billing.list()
for billing in billings:
    print(billing.id, billing.status)

print(len(billings))
```

### Gerenciamento de clientes

```python
from abacatepay.customers import CustomerMetadata

customer = CustomerMetadata(  # Também pode ser apenas um dicionário
    email="customer@example.com",
    name="Customer Name",
    cellphone="(12) 3456-7890",
    tax_id="123-456-789-10"
)

created_customer = client.customers.create(customer)
print(created_customer.id)
```

---

## Contribuindo

Bom-vindo a contribuições para o SDK do AbacatePay! Siga os passos abaixo para começar:

1. Fork o repositório no GitHub.

2. Clone seu fork localmente:

   ```bash
   git clone https://github.com/your-username/abacatepay.git
   cd abacatepay
   ```

3. Configure o ambiente virtual usando [poetry](https://python-poetry.org/):
> Se você não tiver poetry instalado, você pode instalar seguindo as instruções [aqui](https://python-poetry.org/docs/#installing-with-the-official-installer).

   ```bash
   poetry install
   ```

4. Faça suas alterações em uma nova branch:

   ```bash
   git checkout -b feature-name
   ```

5. Execute os testes para garantir que suas alterações não quebrem a funcionalidade existente:

   ```bash
   poetry run pytest
   ```

6. Commit suas alterações e envie a branch:

   ```bash
   git add .
   git commit -m "Add feature or fix description"
   git push origin feature-name
   ```

7. Abra um pull request no GitHub e descreva suas alterações.



================================================
FILE: abacatepay/__init__.py
================================================
"""
The Python SDK for the AbacatePay API

Basic usage:
```python
import abacatepay
from abacatepay.models import Product

token = "<your api token>"
client = AbacatePay(token)

billing = client.billing.create(products=[Product(externalId="123", name="Teste", quantity=1, price=101, description="Teste")], returnURL="https://abacatepay.com", completionUrl="https://abacatepay.com")
print(billing.data.url)
# > https://abacatepay.com/pay/aaaaaaa
```

More examples found on https://docs.abacatepay.com/
"""

from .billings import BillingClient
from .customers import CustomerClient
from .coupons import CouponClient
from .pixQrCode import PixQrCodeClient

class AbacatePay:
    def __init__(self, api_key: str):
        self.billing = BillingClient(api_key)
        self.customers = CustomerClient(api_key)
        self.coupons = CouponClient(api_key)
        self.pixQrCode = PixQrCodeClient(api_key)



================================================
FILE: abacatepay/constants.py
================================================
from typing import Literal

MINIMUM_VALUE = 100
BASE_URL = "https://api.abacatepay.com/v1"
VERSION = "1.0.7"
USER_AGENT = f"Python SDK {VERSION}"

BILLING_STATUS = Literal['PENDING', 'EXPIRED', 'CANCELLED', 'PAID', 'REFUNDED']
BILLING_METHODS = Literal['PIX']
BILLING_KINDS = Literal['ONE_TIME', 'MULTIPLE_PAYMENTS']
DISCOUNT_KINDS = Literal['PERCENTAGE', 'FIXED']
COUPON_STATUS = Literal['PENDING', 'EXPIRED', 'CANCELLED', 'PAID', 'REFUNDED']
PIX_QR_CODE_STATUS = Literal['PENDING', 'EXPIRED', 'CANCELLED', 'PAID', 'REFUNDED']


================================================
FILE: abacatepay/base/___init___.py
================================================
"""
Module responsible for managing all objects that serve as a foundation for other objects.
"""


================================================
FILE: abacatepay/base/client.py
================================================
import requests
from typing import Literal
from ..constants import USER_AGENT
from ..utils.exceptions import raise_for_status, APITimeoutError, APIConnectionError


class BaseClient:
    def __init__(self, api_key: str):
        self.__api_key = api_key

    def _request(
        self,
        url: str,
        method: Literal["GET", "POST", "PUT", "PATCH", "DELETE"] = "GET",
        **kwargs,
    ):
        request = requests.Request(
            method,
            url,
            headers={
                "Authorization": f"Bearer {self.__api_key}",
                "User-Agent": USER_AGENT,
            },
            **kwargs,
        )
        try:
            prepared_request = request.prepare()
            with requests.Session() as s:
                response = s.send(prepared_request)

            raise_for_status(response)
            return response

        except requests.exceptions.Timeout:
            raise APITimeoutError(request=request)

        except requests.exceptions.ConnectionError:
            raise APIConnectionError(message="Connection error.", request=request)



================================================
FILE: abacatepay/billings/__init__.py
================================================
from .client import BillingClient
from .models import (
    Billing,
    BillingList,
    BillingIn,
    BillingMetadata,
)

__all__ = [
    "BillingClient",
    "Billing",
    "BillingList",
    "BillingIn",
    "BillingMetadata",
]



================================================
FILE: abacatepay/billings/client.py
================================================
from logging import getLogger
from typing import Union
from ..base.client import BaseClient
from ..constants import BASE_URL
from .models import Billing, BillingIn, BillingList
from ..utils.helpers import prepare_data

logger = getLogger(__name__)


class BillingClient(BaseClient):
    def create(self, data: Union[BillingIn | dict], **kwargs) -> Billing:
        """
        Create a new billing.

        Args:
            data (BillingIn): an instance of `abacatepay.billings.models.BillingIn` a dict \
            or the named params following the model schema.

        Keyword args:
            products (List[Product]): List of products to be billed.
            returnURL (str): The URL the user will be redirected to after the billing is completed.
            completionUrl (str): The URL the API will make a POST request after the billing is completed.
            methods (List[BILLING_METHODS]): The payment methods to be accepted. Defaults to ["PIX"].
            frequency (BILLING_KINDS): The frequency of the billing. Defaults to "ONE_TIME".
            customerId (str): The ID of the customer. If provided, the customer information won't be required.
            customer (CustomerMetadata): The customer information. If customerId is provided, this parameter is ignored.

        Returns:
            Billing: The response with the billing data.
        """
        json_data = prepare_data(data or kwargs, BillingIn)
        logger.debug('creating billing: %s', json_data)

        response = self._request(
            f"{BASE_URL}/billing/create",
            method="POST",
            json=json_data,
        )
        return Billing(**response.json()["data"])

    def list(self) -> BillingList:
        """
        List all bills.

        Returns:
            BillingList: A list of billing objects.
        """
        logger.debug(f"Listing bills with URL: {BASE_URL}/billing/list")
        response = self._request(f"{BASE_URL}/billing/list", method="GET")
        return BillingList.model_validate({'data': response.json()["data"]})



================================================
FILE: abacatepay/billings/models.py
================================================
from typing import Annotated, Iterator, List, Optional

from pydantic import (
    AliasChoices,
    AwareDatetime,
    BaseModel,
    Field,
    StringConstraints,
)

from ..constants import BILLING_KINDS, BILLING_METHODS, BILLING_STATUS
from ..customers.models import CustomerID, CustomerInline, CustomerMetadata
from ..products.models import Product, ProductInline

HttpUrl = Annotated[
    str,
    StringConstraints(
        pattern=(
            r"^(https?:\/\/)"  # Protocol (http or https)
            r"(([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,})"  # Domain (including subdomains)
            r"(\/[^\s]*)?$" # Optional path
        )
    )
]

class BillingIn(BaseModel):
    """Represents a billing model to creation

    Args:
        frequency (BILLING_KINDS): The billing frequency. Defaults to `ONE_TIME`.
        methods (List[BILLING_METHODS]): the allowed method to the billing. Defaults to ['PIX']
        products (List[Product]): The list of products in the billing.
        completion_url (HttpUrl): the redirect URL when the payment is completed.
        return_url (HttpUrl): the redirect URL when the user clicks on the "back" button.
        customer_id (Optional[CustomerID]): Unique identifier of the billing.
        customer (CustomerMetadata): Your customer information. Defaults to {}.
    """
    frequency: BILLING_KINDS = 'ONE_TIME'
    methods: List[BILLING_METHODS] = ['PIX']
    products: List[Product]
    return_url: HttpUrl = Field(serialization_alias='returnUrl')
    completion_url: HttpUrl = Field(serialization_alias='completionUrl')
    customer_id: Optional[CustomerID] = Field(None, serialization_alias='customerId')
    customer: CustomerMetadata | dict = {}


class BillingMetadata(BaseModel):
    """model of a billing metadata

    Args:
        completion_url (str): the redirect URL when the payment is completed.
        return_url (str): the redirect URL when the user clicks on the "back" button.
        fee (int): the billing fee.
    """
    completion_url: str = Field(
        validation_alias=AliasChoices('completion_url', 'completionUrl'),
        serialization_alias='completionUrl',
    )
    return_url: str = Field(
        validation_alias=AliasChoices('return_url', 'returnUrl'),
        serialization_alias='returnUrl',
    )
    fee: int


class Billing(BaseModel):
    """Billing model

    Args:
        id (str): Unique identifier of the billing.
        url (str): the URL which the user can complete the payment.
        amount (int): the amount to be paid (in cents).
        status (BILLING_STATUS): the current billing status.
        dev_mode (bool): if it's operating in dev mode.
        methods (List[BILLING_METHODS]): the allowed method to the billing.
        products (List[ProductInline]): The list of products in the billing.
        frequency (BILLING_KINDS): The billing frequency.
        next_billing (Optional[AwareDatetime]): date and time of the next billing.
        customer (Optional[CustomerInline]): the data of the customer that the billing belongs to.
        created_at (AwareDatetime): The date and time when the billing was created.
        updated_at (AwareDatetime): the date and time of the last billing update.
        allow_cupons (bool): If the billing has allowed coupons or not.
        coupons (List[Coupon]): the available coupons.
        coupons_used (List[Coupon]): active coupons for this billing.
        metadata (BillingMetadata): the billing metadata.
    """
    id: str
    url: str
    amount: int
    status: BILLING_STATUS
    dev_mode: bool = Field(validation_alias='devMode')
    methods: List[BILLING_METHODS]
    products: List[ProductInline]
    frequency: BILLING_KINDS
    next_billing: Optional[AwareDatetime] = Field(
        None,
        validation_alias=AliasChoices('next_billing', 'nextBilling'),
        serialization_alias='nextBilling',
    )
    customer: Optional[CustomerInline] = None
    created_at: AwareDatetime = Field(validation_alias='createdAt')
    updated_at: AwareDatetime = Field(validation_alias='updatedAt')
    coupons: List[str]
    coupons_used: List[str] = Field(validation_alias='couponsUsed')
    metadata: BillingMetadata


class BillingList(BaseModel):
    """Represents a list of Billings. It can be directly iterated and
    supports the usage of the `len` function.

    Args:
        data (List[Billing]): the list object having all the billings.
    """
    data: List[Billing]

    def __len__(self) -> int:
        return len(self.data)

    def __iter__(self) -> Iterator[Billing]:
        return self.data.__iter__()



================================================
FILE: abacatepay/coupons/__init__.py
================================================
from .client import CouponClient
from .models import (
    Coupon,
    CouponIn
)
__all__ = [
    "CouponClient",
    "Coupon",
    "CouponIn",
]


================================================
FILE: abacatepay/coupons/client.py
================================================
from logging import getLogger
from typing import Optional
from ..base.client import BaseClient
from ..constants import BASE_URL, DISCOUNT_KINDS
from ..utils.helpers import prepare_data
from .models import Coupon, CouponIn

logger = getLogger(__name__)

class CouponClient(BaseClient):
  def create(self, data: Optional[CouponIn | dict] = None, **kwargs) -> Coupon:
    """
    Create a new coupon.

    Args:
        data (Coupon): an instance of `abacatepay.coupons.models.Coupon` a dict \
        or the named params following the model schema.

    Keyword args:
        code (str): The unique code for the coupon.
        discount_kind (DISCOUNT_KINDS): The type of discount (e.g., percentage or fixed amount).
        discount (int): The value of the discount.
        notes (Optional[str]): A description or note about the coupon. Defaults to None.
            - Serialization alias: 'notes'
            - Example: "Cupom de desconto pro meu público"
        max_redeems (Optional[int]): The maximum number of times the coupon can be redeemed.
            Defaults to -1 for unlimited redemptions.
        metadata (Optional[dict]): Additional metadata for the coupon. Defaults to None.

    Returns:
        Coupon: The response with the coupon data.
    """
    json_data = prepare_data(data or kwargs, CouponIn)
    logger.debug('creating coupon: %s', json_data)

    response = self._request(
        f"{BASE_URL}/coupon/create",
        method="POST",
        json=json_data,
    )
    logger.debug(f"Response from coupon creation: {response.json()}")
    return Coupon.model_validate(response.json()["data"], by_alias=True)
  
  def list(self):
    """
    List all coupons.
    Returns:
        list[Coupon]: A list of coupon objects.
    """
    logger.debug(f"Listing coupons with URL: {BASE_URL}/coupon/list")
    response = self._request(f"{BASE_URL}/coupon/list", method="GET")
    data = response.json().get("data", [])

    if not data:
        logger.warning("No coupons found in the response.")
        return []  # Retorna uma lista vazia ou outro valor padrão

    return [Coupon.model_validate(item) for item in data]


================================================
FILE: abacatepay/coupons/models.py
================================================
from typing import Optional

from pydantic import (
    BaseModel,
    Field,
)

from ..constants import DISCOUNT_KINDS

class CouponIn(BaseModel):
    """
    Represents a coupon model for creation.

    Attributes:
        code (str): The unique code for the coupon.
        discount_kind (DISCOUNT_KINDS): The type of discount (e.g., percentage or fixed amount).
        discount (int): The value of the discount.
        notes (Optional[str]): A description or note about the coupon. Defaults to None.
            - Serialization alias: 'notes'
            - Example: "Cupom de desconto pro meu público"
        max_redeems (Optional[int]): The maximum number of times the coupon can be redeemed.
            Defaults to -1 for unlimited redemptions.
        metadata (Optional[dict]): Additional metadata for the coupon. Defaults to None.
    """
    code: str
    discount_kind: DISCOUNT_KINDS =  Field(DISCOUNT_KINDS, serialization_alias='discountKind', description="Type of discount (e.g., percentage or fixed amount)", examples=["PERCENTAGE", "FIXED_AMOUNT"])
    discount:int
    notes: Optional[str] = Field(None, serialization_alias='notes', description="Coupon's description", examples=["Cupom de desconto pro meu público"])
    max_redeems: Optional[int] = Field(-1, description="Maximum number of times the coupon can be redeemed. Defaults to -1 for unlimited.", serialization_alias='maxRedeems')
    metadata: Optional[dict] = Field({}, description="Additional metadata for the coupon.")

class Coupon(BaseModel):
    """
    Represents a coupon model for retrieval.

    Attributes:
        id (str): The unique identifier for the coupon.
        discount_kind (str): The type of discount (e.g., percentage or fixed amount).
        discount (int): The value of the discount.
        status (str): The current status of the coupon (e.g., ACTIVE, INACTIVE).
        notes (Optional[str]): A description or note about the coupon.
        max_redeems (int): The maximum number of times the coupon can be redeemed.
        redeems_count (int): The number of times the coupon has been redeemed.
        created_at (str): The timestamp when the coupon was created.
        updated_at (str): The timestamp when the coupon was last updated.
    """
    id: str
    discount_kind: str = Field(..., alias='discountKind', description="Type of discount (e.g., percentage or fixed amount)")
    discount: int
    status: str
    notes: Optional[str] = Field(None, validation='notes', description="Coupon's description")
    max_redeems: int = Field(-1, validation_alias='maxRedeems', description="Maximum number of times the coupon can be redeemed.")
    redeems_count: int = Field(0, validation_alias='redeemsCount', description="Number of times the coupon has been redeemed.")
    created_at: str = Field(..., validation_alias='createdAt', description="Timestamp when the coupon was created.")
    updated_at: str = Field(..., validation_alias='updatedAt', description="Timestamp when the coupon was last updated.")
    dev_mode: bool = Field(..., validation_alias='devMode', description="Indicates if the coupon is in development mode.")


================================================
FILE: abacatepay/customers/__init__.py
================================================
from .client import CustomerClient
from .models import Customer, CustomerMetadata

__all__ = [
    "Customer",
    "CustomerClient",
    "CustomerMetadata",
]



================================================
FILE: abacatepay/customers/client.py
================================================
from ..constants import (
    BASE_URL,
)
from .models import CustomerMetadata, Customer
from ..base.client import BaseClient
from logging import getLogger
from ..utils.helpers import prepare_data
from typing import Optional

logger = getLogger(__name__)


class CustomerClient(BaseClient):
    def create(self, customer: Optional[CustomerMetadata | dict] = None, **kwargs) -> Customer:
        """creates a new customer using an or named arguments

        Args:
            customer (Optional[CustomerMetadata  |  dict], optional): You customer data, it can be \
            a dict, an instance of `abacatepay.customers.CustomerMetadata`.

        Returns:
            Customer: An instance of the new customer.
        """
        logger.debug(f"Creating customer with URL: {BASE_URL}/customer/create")

        json_data = prepare_data(customer or kwargs, CustomerMetadata)
        response = self._request(
            f"{BASE_URL}/customer/create",
            method="POST",
            json=json_data,
        )
        return Customer(**response.json()["data"])

    def list(self) -> list[Customer]:
        logger.debug(f"Listing customers with URL: {BASE_URL}/customer/list")
        response = self._request(f"{BASE_URL}/customer/list", method="GET")
        return [Customer(**bill) for bill in response.json()["data"]]



================================================
FILE: abacatepay/customers/models.py
================================================
from typing import Annotated
from pydantic import BaseModel, Field, AliasChoices, StringConstraints


class CustomerMetadata(BaseModel):
    """Customer model

    Args:
        tax_id (str):  the customer identifier such as CPF or CNPJ.
        name (str): the customer name
        email (str): the customer email address
        cellphone: (str): the customer phone number.
    """
    tax_id: str = Field(
        serialization_alias='taxId',
        validation_alias=AliasChoices('taxId', 'tax_id'),
    )
    name: str
    email: str
    cellphone: str


class CustomerInline(BaseModel):
    """The customer model attached to other models
    
    Args:
        metadata (Customer): the metadata of the customer.
    """
    metadata: CustomerMetadata


CustomerID = Annotated[
    str,
    StringConstraints(pattern=r'^cust_[A-Za-z0-9]+$')
]


class Customer(CustomerInline):
    """
    Customer returned by API.

    Args:
        id (CustomerID): the customer unique ID in abacatepay.
        tax_id (str) the customer identification (CPF or CNPJ).
        email (str): the customer's email
        name (str): the customer's name
        cellphone (str): the customer's phone number
    """
    id: CustomerID

    @property
    def tax_id(self) -> str:
        """the customer identification (CPF or CNPJ)."""
        return self.metadata.tax_id
    
    @property
    def name(self) -> str:
        """the customer's name"""
        return self.metadata.name
    
    @property
    def email(self) -> str:
        """the customer's email"""
        return self.metadata.email
    
    @property
    def cellphone(self) -> str:
        """the customer's phone number"""
        return self.metadata.cellphone



================================================
FILE: abacatepay/pixQrCode/__init__.py
================================================
from .client import PixQrCodeClient
from .models import (PixQrCode,
                     PixStatus,
                     PixQrCodeIn
)

__all__ = [
    "PixQrCodeClient",
    "PixQrCode",
    "PixStatus",
    "PixQrCodeIn",
]


================================================
FILE: abacatepay/pixQrCode/client.py
================================================
from logging import getLogger
from typing import Union, Optional
from ..base.client import BaseClient
from ..constants import BASE_URL
from .models import PixQrCode, PixStatus, PixQrCodeIn
from ..customers.models import CustomerMetadata

from ..utils.helpers import prepare_data
logger = getLogger(__name__)

class PixQrCodeClient(BaseClient):
  def create(self, data: Union[PixQrCodeIn, dict], **kwargs) -> PixQrCode:
    """
    Create a new Pix QR Code.

    Args:
        amount (int): The amount to be paid in cents.
        expires_in (int, optional): The expiration time in seconds. Defaults to None.
        description (str, optional): A description for the Pix QR Code. Defaults to None.
        customer (CustomerMetadata | dict, optional): Customer information. Defaults to None.
    Returns:
        PixQrCode: The created Pix QR Code object.
    """
    json_data = prepare_data(data or kwargs, PixQrCodeIn)
    logger.debug('Creating Pix QR Code: %s', json_data)

    response = self._request(
        f"{BASE_URL}/pixQrCode/create",
        method="POST",
        json=json_data,
    )
    logger.debug('Pix QR Code created successfully: %s', response.json())
    return PixQrCode.model_validate(response.json()["data"])

  def check(self, id: str) -> PixStatus:
    """
    Get the status of a Pix QR Code.

    Args:
        ID (str): The unique identifier of the Pix QR Code.

    Returns:
        PixStatus: The status of the Pix QR Code.
    """
    logger.debug(f"Getting status for Pix QR Code ID: {id}")
    response = self._request(
        f"{BASE_URL}/pixQrCode/check?id={id}",
        method="GET",
    )
    return PixStatus.model_validate(response.json()["data"])

  def simulate(self, id: str, metadata:Optional[dict] = {}) -> PixQrCode:
        """
        Simulate a Pix QR Code.

        Args:
            id (str): The unique identifier of the Pix QR Code.
            metadata (dict, optional): Additional metadata for the simulation. Defaults to {}.

        Returns:
            PixQrCode: The simulated Pix QR Code object.
        """
        logger.debug(f"Simulating Pix QR Code ID: {id}")
        response = self._request(
            f"{BASE_URL}/pixQrCode/simulate-payment?id={id}",
            method="POST",
            json=metadata,
        )
        return PixQrCode.model_validate(response.json()["data"])


================================================
FILE: abacatepay/pixQrCode/models.py
================================================
from pydantic import BaseModel, Field
from typing import Optional, Union
from ..constants import PIX_QR_CODE_STATUS
from ..customers.models import CustomerMetadata

class PixQrCode(BaseModel):
  id: str = Field(..., description="Unique identifier of the Pix QRCode.", example="pix_char_123456")
  amount: int = Field(..., description="Amount to be paid.", example=100)
  status: PIX_QR_CODE_STATUS = Field(..., description="Information about the status of the Pix QRCode. Options: PENDING, EXPIRED, CANCELLED, PAID, REFUNDED", example="PENDING")
  dev_mode: bool = Field(..., description="Environment in which the Pix QRCode was created.", example=True, validation_alias="devMode")
  brcode: str = Field(..., description="Copy-and-paste code of the Pix QRCode.", example="00020101021226950014br.gov.bcb.pix", validation_alias="brCode")
  brcode_base64: str = Field(..., description="Base64 image of the Pix QRCode.", example="data:image/png;base64,iVBORw0KGgoAAA", validation_alias="brCodeBase64")
  platform_fee: int = Field(..., description="Platform fees.", example=80, validation_alias="platformFee")
  created_at: str = Field(..., description="Creation date of the Pix QRCode.", example="2025-03-24T21:50:20.772Z", validation_alias="createdAt")
  updated_at: str = Field(..., description="Update date of the Pix QRCode.", example="2025-03-24T21:50:20.772Z", validation_alias="updatedAt")
  expires_at: str = Field(..., description="Expiration date of the Pix QRCode.", example="2025-03-25T21:50:20.772Z", validation_alias="expiresAt")

class PixStatus(BaseModel):
  status: PIX_QR_CODE_STATUS = Field(..., description="Information about the status of the Pix QRCode. Options: PENDING, EXPIRED, CANCELLED, PAID, REFUNDED", example="PENDING")
  expires_at: str = Field(None, description="Expiration date of the Pix QRCode.", example="2025-03-25T21:50:20.772Z")

class PixQrCodeIn(BaseModel):
  amount: int = Field(..., description="Amount to be paid in cents.", example=100)
  expires_in: Optional[int] = Field(None, description="Expiration time in seconds. Defaults to None.", example=3600)
  description: Optional[str] = Field(None, description="A description for the Pix QR Code. Defaults to None.", example="Payment for services")
  customer: Optional[Union[dict, CustomerMetadata]] = Field(
        {}, description="Customer information. Optional."
  )


================================================
FILE: abacatepay/products/__init__.py
================================================
from .models import Product

__all__ = ['Product']



================================================
FILE: abacatepay/products/models.py
================================================
from typing import Optional, Annotated
from annotated_types import Ge
from pydantic import BaseModel, Field, AliasChoices


class Product(BaseModel):
    """A product to be appended to a billing when it's being created

    Args:
        external_id (str): the product ID in your application.
        name (str): the product name.
        description (Optional[str]): a detailed description of the product.
        quantity (int): the number of units of the given product (min: 1).
        price (int): the price of the product in cents (min: 100).
    """
    external_id: str = Field(
        validation_alias=AliasChoices('externalId', 'external_id'),
        serialization_alias='externalId',
    )
    name: str
    description: Optional[str] = None
    quantity: Annotated[int, Ge(1)]
    price: Annotated[int, Ge(100)]


class ProductInline(BaseModel):
    """Represents a product inside a Billing.
    
    Args:
        id (str): the product ID.
        external_id (str): the product ID in your application.
        quantity (int): the number of units of the given product.
    """
    id: str
    external_id: str = Field(
        validation_alias=AliasChoices('external_id', 'externalId'),
        serialization_alias='externalId',
    )
    quantity: Annotated[int, Ge(1)]



================================================
FILE: abacatepay/utils/exceptions.py
================================================
import requests
from typing import Literal


class APIError(Exception):
    """The exception was raised due to an API error."""

    message: str
    request: str

    def __init__(self, message: str, request: requests.Request) -> None:
        super().__init__(message)
        self.message = """The exception was raised due to an API error."""
        self.request = request

    def __str__(self):
        if self.message:
            return f"{self.message}"


class APIStatusError(APIError):
    """Raised when an API response has a status code of 4xx or 5xx."""

    response: requests.Response
    status_code: int

    def __init__(
        self, message: str | None = None, *, response: requests.Response
    ) -> None:
        super().__init__(message, response.request)
        self.response = response
        self.status_code = response.status_code


class ForbiddenRequest(APIStatusError):
    """
    Means that the request was unsuccessful due to a forbidden request. Maybe your API key is wrong?
    """

    message: str | None
    status_code: Literal[401] = 401

    def __init__(self, response: requests.Response, message: str | None = None):
        super().__init__(message, response=response)
        self.message = "Means that the request was unsuccessful due to a forbidden request. Maybe your API key is wrong?"
        self.response = response
        self.status_code: Literal[401] = 401

    def __str__(self):
        if self.message:
            return f"{self.message} \n Status Code: {self.response.status_code} | Response: {self.response.text}"
        return self.response.content


class UnauthorizedRequest(APIStatusError):
    """
    Means that the request was unsuccessful due to a forbidden request. Maybe your API key doesn't have enought permissions
    """

    message: str | None
    status_code: Literal[403] = 403

    def __init__(self, response: requests.Response, message: str | None = None):
        super().__init__(message, response=response)
        self.message = "Means that the request was unsuccessful due to a forbidden request. Maybe your API key doesn't have enought permissions"
        self.response = response
        self.status_code: Literal[403] = 403

    def __str__(self):
        if self.message:
            return f"{self.message} | Status Code: {self.response.status_code} | Response: {self.response.text}"
        return self.response.content


class APIConnectionError(APIError):
    """The request was unsuccessful due to a connection error. Check your internet connection"""

    def __init__(
        self,
        *,
        message: str = "The request was unsuccessful due to a connection error. Check your internet connection",
        request: requests.Request,
    ) -> None:
        super().__init__(message, request)


class APITimeoutError(APIConnectionError):
    """The request got timed out. You might try checking your internet connection."""

    def __init__(self, request: requests.Request) -> None:
        super().__init__(
            message="Request timed out. Check your internet connection", request=request
        )


class BadRequestError(APIStatusError):
    """The request was unsuccessful due to a bad request. Maybe the request syntax is wrong"""

    status_code: Literal[400] = 400

    def __init__(self, response: requests.Response) -> None:
        self.response = response

    def __str__(self):
        return f"The request was unsuccessful due to a bad request. Maybe the request syntax is wrong. Message error: {self.response.json()}"


class NotFoundError(APIStatusError):
    status_code: Literal[404] = 404

    def __str__(self):
        return """The request was unsuccessful due to a not found error. Error status 404 | Requested URL: {}""".format(
            self.response.url
        )


class InternalServerError(APIStatusError):
    """The request was unsuccessful due to an internal server error."""

    status_code: Literal[500] = 500

    def __init__(self, response: requests.Response) -> None:
        super().__init__(
            message="The request was unsuccessful due to an internal server error. It's not your fault, just try again later.",
            response=response,
        )


def raise_for_status(response: requests.Response) -> None:
    code_exc_dict = {
        400: BadRequestError(response=response),
        401: UnauthorizedRequest(response=response),
        403: ForbiddenRequest(response=response),
        404: NotFoundError(response=response),
        500: InternalServerError(response=response),
    }

    code = response.status_code
    if code == 200:
        return
    
    if code not in code_exc_dict  and code >= 400:
        raise APIStatusError(message=response.text, response=response)
    
    raise code_exc_dict.get(
        response.status_code,
        APIError(message=response.text, request=response.request)
    )
    



================================================
FILE: abacatepay/utils/helpers.py
================================================
from pydantic import BaseModel


def prepare_data(data, model_cls: type[BaseModel], *, use_alias: bool = True) -> dict:
    """It formats the data to be in compliance with the given model class to be sent to the API

    Args:
        data (BaseModel | dict): the user input data.
        model_cls (type[BaseModel]): the model that will dumps.
        use_alias (bool, optional): if `True` dumps by alias. Defaults to True.
    """
    if isinstance(data, model_cls):
        validated_data = data.model_dump(by_alias=use_alias)
        return {k: v for k, v in validated_data.items() if v != {}}

    elif isinstance(data, dict):
        validated_data = model_cls.model_validate(data).model_dump(by_alias=use_alias)
        return {k: v for k, v in validated_data.items() if v != {}}

    raise TypeError('Invalid data type.')




================================================
FILE: tests/conftest.py
================================================
import pytest
from abacatepay.products import Product
from abacatepay.customers.models import CustomerMetadata


@pytest.fixture
def invalid_token_response(responses):
    responses.add(
        responses.GET,
        "https://api.abacatepay.com/v1/billing/list",
        status=401,
    )
    return responses

@pytest.fixture
def list_billings_response(responses):
    responses.add(
        responses.GET,
        "https://api.abacatepay.com/v1/billing/list",
        json={
            "data": [
                {
                    "allowCoupons": False,
                    "amount": 100,
                    "coupons": [],
                    "couponsUsed": [],
                    "createdAt": "2025-03-17T17:41:46.306Z",
                    "customer": {
                        "metadata": {
                            "cellphone": "(99) 9999-9999",
                            "email": "john@email.com",
                            "name": "John Doe",
                            "taxId": "445.665.140-72"
                        }
                    },
                    "devMode": True,
                    "frequency": "ONE_TIME",
                    "id": "bill_sccfTWMq5DLxWj1MeRqgBpzU",
                    "metadata": {
                        "completionUrl": "https://example/completion",
                        "fee": 100,
                        "returnUrl": "https://example.com/return"
                    },
                    "methods": [
                        "PIX"
                    ],
                    "products": [
                        {
                            "externalId": "1",
                            "id": "prod_0g0GhPwBBRKX1qBjzjJr2HaK",
                            "quantity": 1
                        }
                    ],
                    "status": "PENDING",
                    "updatedAt": "2025-03-17T17:41:46.306Z",
                    "url": "https://abacatepay.com/pay/bill_sccfTWMq5DLxWj1MeRqgBpzU"
                },
            ],
            "error": None
        },
        status=200,
    )
    return responses

@pytest.fixture
def list_more_than_one_billing_response(responses):
    responses.add(
        responses.GET,
        "https://api.abacatepay.com/v1/billing/list",
        json={
            "data": [
                {
                    "allowCoupons": False,
                    "amount": 100,
                    "coupons": [],
                    "couponsUsed": [],
                    "createdAt": "2025-03-17T17:41:46.306Z",
                    "customer": {
                        "metadata": {
                            "cellphone": "(99) 9999-9999",
                            "email": "john@email.com",
                            "name": "John Doe",
                            "taxId": "445.665.140-72"
                        }
                    },
                    "devMode": True,
                    "frequency": "ONE_TIME",
                    "id": "bill_sccfTWMq5DLxWj1MeRqgBpzU",
                    "metadata": {
                        "completionUrl": "https://example/completion",
                        "fee": 100,
                        "returnUrl": "https://example.com/return"
                    },
                    "methods": [
                        "PIX"
                    ],
                    "products": [
                        {
                            "externalId": "1",
                            "id": "prod_0g0GhPwBBRKX1qBjzjJr2HaK",
                            "quantity": 1
                        }
                    ],
                    "status": "PENDING",
                    "updatedAt": "2025-03-17T17:41:46.306Z",
                    "url": "https://abacatepay.com/pay/bill_sccfTWMq5DLxWj1MeRqgBpzU"
                },{
                    "allowCoupons": False,
                    "amount": 100,
                    "coupons": [],
                    "couponsUsed": [],
                    "createdAt": "2025-03-17T17:41:46.306Z",
                    "customer": {
                        "metadata": {
                            "cellphone": "(99) 9999-9999",
                            "email": "john@email.com",
                            "name": "John Doe",
                            "taxId": "445.665.140-72"
                        }
                    },
                    "devMode": True,
                    "frequency": "ONE_TIME",
                    "id": "bill_sccfTWMq5DLxWj1MeRqgBpzU",
                    "metadata": {
                        "completionUrl": "https://example/completion",
                        "fee": 100,
                        "returnUrl": "https://example.com/return"
                    },
                    "methods": [
                        "PIX"
                    ],
                    "products": [
                        {
                            "externalId": "1",
                            "id": "prod_0g0GhPwBBRKX1qBjzjJr2HaK",
                            "quantity": 1
                        }
                    ],
                    "status": "PENDING",
                    "updatedAt": "2025-03-17T17:41:46.306Z",
                    "url": "https://abacatepay.com/pay/bill_sccfTWMq5DLxWj1MeRqgBpzU"
                },
            ],
            "error": None
        },
        status=200,
    )
    return responses

@pytest.fixture
def billing_response_sample():
    """return a sample data of the billing returned by API"""
    return {
        "allowCoupons": False,
        "amount": 100,
        "coupons": [],
        "couponsUsed": [],
        "createdAt": "2025-03-17T17:41:46.306Z",
        "customer": {
            "metadata": {
                "cellphone": "(99) 9999-9999",
                "email": "john@email.com",
                "name": "John Doe",
                "taxId": "445.665.140-72"
            }
        },
        "devMode": True,
        "frequency": "ONE_TIME",
        "id": "bill_sccfTWMq5DLxWj1MeRqgBpzU",
        "metadata": {
            "completionUrl": "https://8c75-45-7-165-133.ngrok-free.app/completion",
            "fee": 100,
            "returnUrl": "https://8c75-45-7-165-133.ngrok-free.app/return"
        },
        "methods": [
            "PIX"
        ],
        "products": [
            {
                "externalId": "1",
                "id": "prod_0g0GhPwBBRKX1qBjzjJr2HaK",
                "quantity": 1
            }
        ],
        "status": "PENDING",
        "updatedAt": "2025-03-17T17:41:46.306Z",
        "url": "https://abacatepay.com/pay/bill_sccfTWMq5DLxWj1MeRqgBpzU"
    }


@pytest.fixture
def one_product_sample():
    """returns an instance of the product model"""
    return Product(
        external_id='ext_999',
        name='sample prod',
        description='sample',
        quantity=1,
        price=100,
    )

@pytest.fixture
def one_customer_metadata_sample():
    """returns an instance of the CustomerMetadata model"""
    return CustomerMetadata(
        name='sample customer',
        tax_id='445.665.140-72',
        email='cust@email.com',
        cellphone="(11) 4002-8922"
    )



================================================
FILE: tests/integration/__init__.py
================================================



================================================
FILE: tests/integration/test_auth.py
================================================
import pytest
from abacatepay import AbacatePay
from abacatepay.utils.exceptions import UnauthorizedRequest


def test_wrong_key_running_function(invalid_token_response):
    rightKey = "Bearer 123456789"

    client = AbacatePay(rightKey)
    with pytest.raises(UnauthorizedRequest):
        client.billing.list()


================================================
FILE: tests/integration/billings/__init__.py
================================================



================================================
FILE: tests/integration/billings/test_client.py
================================================
from abacatepay.billings.client import BillingClient
from abacatepay.billings.models import BillingList, BillingIn
from abacatepay.products import Product

client = BillingClient("dummy-token")


def test_list_billings(list_billings_response):
    """Tests if listing billings returns exactly one billing entry."""
    billings = client.list()
    assert len(billings) == 1


def test_list_more_than_one_billing(list_more_than_one_billing_response):
    """Tests if listing billings returns more than one billing entry when multiple billings exist."""
    billings = client.list()
    assert len(billings) == 2


def test_list_billings_return_type(list_billings_response):
    """Tests if the list method returns a BillingList instance."""
    billings = client.list()
    assert isinstance(billings, BillingList)


def test_create_billing_passing_a_dict(billing_response_sample, responses):
    """Tests if a billing can be created by passing a dictionary."""
    responses.add(
        responses.POST,
        'https://api.abacatepay.com/v1/billing/create',
        json={'data': billing_response_sample, 'error': None},
        status=200
    )

    billing = client.create(
        {
            'products': [
                Product(
                    external_id=billing_response_sample['products'][0]['externalId'],
                    name='test',
                    quantity=billing_response_sample['products'][0]['quantity'],
                    price=100,
                    description="test product",
                ),
            ],
            'return_url': billing_response_sample['metadata']['returnUrl'],
            'completion_url': billing_response_sample['metadata']['completionUrl'],
        }
    )

    assert billing.id == billing_response_sample['id']
    assert billing.url == billing_response_sample['url']


def test_create_billing_passing_billing_in_model(billing_response_sample, responses):
    """Tests if a billing can be created by passing a BillingIn model instance."""
    responses.add(
        responses.POST,
        'https://api.abacatepay.com/v1/billing/create',
        json={'data': billing_response_sample, 'error': None},
        status=200
    )

    billing = client.create(
        BillingIn(
            products=[
                Product(
                    external_id=billing_response_sample['products'][0]['externalId'],
                    name='test',
                    quantity=billing_response_sample['products'][0]['quantity'],
                    price=100,
                    description="test product",
                ),
            ],
            return_url=billing_response_sample['metadata']['returnUrl'],
            completion_url=billing_response_sample['metadata']['completionUrl'],
        )
    )

    assert billing.id == billing_response_sample['id']
    assert billing.url == billing_response_sample['url']


def test_create_billing_passing_named_arguments(billing_response_sample, responses):
    """Tests if a billing can be created using named arguments."""
    responses.add(
        responses.POST,
        'https://api.abacatepay.com/v1/billing/create',
        json={'data': billing_response_sample, 'error': None},
        status=200
    )

    billing = client.create(
        data=BillingIn(
            products=[
                Product(
                    external_id=billing_response_sample['products'][0]['externalId'],
                    name='test',
                    quantity=billing_response_sample['products'][0]['quantity'],
                    price=100,
                    description="test product",
                ),
        ],
        return_url=billing_response_sample['metadata']['returnUrl'],
        completion_url=billing_response_sample['metadata']['completionUrl'],
    ))


    assert billing.id == billing_response_sample['id']
    assert billing.url == billing_response_sample['url']



================================================
FILE: tests/integration/customers/__init__.py
================================================



================================================
FILE: tests/integration/customers/conftest.py
================================================
import pytest

from abacatepay.customers import CustomerClient
from abacatepay.customers.models import Customer, CustomerMetadata


@pytest.fixture
def customer_client():
    """returns an instance of the `CustomerClient` class using a fake api key"""
    return CustomerClient('fake api key')


@pytest.fixture
def customer_list_response(responses):
    """mocks the response to customer list with 2 customers
    """
    customers = [
        Customer(
            metadata=CustomerMetadata(
                tax_id="445.665.140-72",
                name="customer name",
                email="email@email.com",
                cellphone="(99) 9999-9999",
            ),
            id='cust_fdsjioe1'
        ),
        Customer(
            metadata=CustomerMetadata(
                tax_id="261.474.540-56",
                name="customer name",
                email="email@email.com",
                cellphone="(99) 9999-9999",
            ),
            id='cust_jfeios213'
        ),
    ]

    responses.add(
        responses.GET,
        "https://api.abacatepay.com/v1/customer/list",
        json={'data': [c.model_dump(by_alias=True) for c in customers], 'error': None},
        status=200,
    )



================================================
FILE: tests/integration/customers/test_client.py
================================================
from abacatepay.customers.models import Customer, CustomerMetadata


def test_create_customer_with_model(customer_client, responses, one_customer_metadata_sample):
    customer = Customer(
        metadata=one_customer_metadata_sample,
        id='cust_avjgeigjge'
    )
    responses.add(
        responses.POST,
        "https://api.abacatepay.com/v1/customer/create",
        json={'data': customer.model_dump(by_alias=True), 'error': None},
        status=200,
    )
    
    client = customer_client.create(customer.metadata)
    
    assert client == customer


def test_create_customer_with_dict(customer_client, responses, one_customer_metadata_sample):
    customer = Customer(
        metadata=one_customer_metadata_sample,
        id='cust_avjgeigjge'
    )
    responses.add(
        responses.POST,
        "https://api.abacatepay.com/v1/customer/create",
        json={'data': customer.model_dump(by_alias=True), 'error': None},
        status=200,
    )
    
    client = customer_client.create(one_customer_metadata_sample.model_dump())
    
    assert client == customer


def test_create_customer_with_kwargs(customer_client, responses, one_customer_metadata_sample):
    customer = Customer(
        metadata=one_customer_metadata_sample,
        id='cust_avjgeigjge'
    )
    responses.add(
        responses.POST,
        "https://api.abacatepay.com/v1/customer/create",
        json={'data': customer.model_dump(by_alias=True), 'error': None},
        status=200,
    )
    
    client = customer_client.create(**one_customer_metadata_sample.model_dump())
    
    assert client == customer


def test_list_customers(customer_client, customer_list_response):
    expected_tax_ids = ["445.665.140-72", "261.474.540-56"]
    customers = customer_client.list()

    assert all([c.tax_id == t_id  for c, t_id in zip(customers, expected_tax_ids)])


def test_customer_metadata_serialization(one_customer_metadata_sample):
    result = one_customer_metadata_sample.model_dump(by_alias=True)
    assert result['taxId'] == one_customer_metadata_sample.tax_id


def test_customer_metadata_deserialization(one_customer_metadata_sample):
    data = one_customer_metadata_sample.model_dump(by_alias=True)
    result = CustomerMetadata.model_validate(data)
    assert result.tax_id == data['taxId']



================================================
FILE: tests/unit/__init__.py
================================================



================================================
FILE: tests/unit/base/__init__.py
================================================



================================================
FILE: tests/unit/base/test_client.py
================================================
from http import HTTPStatus as status

import pytest
from requests import Response
from requests.exceptions import ConnectionError, Timeout

from abacatepay.base.client import BaseClient
from abacatepay.utils.exceptions import (
    APIConnectionError,
    APIError,
    APITimeoutError,
    BadRequestError,
    ForbiddenRequest,
    InternalServerError,
    NotFoundError,
    UnauthorizedRequest,
)

url = "https://api.abacatepay.com/v1/billing/list"
client = BaseClient('fake-api-key')


def test_request_return_the_response_if_status_200(responses):
    responses.add(
        responses.GET,
        url,
        status=status.OK,
    )

    response = client._request(url, "GET")

    assert response is not None
    assert isinstance(response, Response)


@pytest.mark.parametrize('status_code,exc_classname', [
    (status.BAD_REQUEST, BadRequestError),
    (status.FORBIDDEN, ForbiddenRequest),
    (status.UNAUTHORIZED, UnauthorizedRequest),
    (status.NOT_FOUND, NotFoundError),
    (status.INTERNAL_SERVER_ERROR, InternalServerError),
    (status.IM_A_TEAPOT, APIError)
])
def test_request_raise_the_correct_exception_when_status_is_different_of_200(responses, exc_classname, status_code):
    responses.add(
        responses.GET,
        url,
        status=status_code,
    )
    
    with pytest.raises(exc_classname):
        client._request(url, "GET")


@pytest.mark.parametrize('requests_exc_class,api_exc_class', [
    (Timeout, APITimeoutError),
    (ConnectionError, APIConnectionError),
])
def test_request_override_requests_timeout_and_connection_error(mocker, requests_exc_class, api_exc_class):
    mocker.patch('abacatepay.base.client.requests.Session.send', side_effect=requests_exc_class)
    with pytest.raises(api_exc_class):
        client._request(url, "GET")



================================================
FILE: tests/unit/billings/test_billing_models.py
================================================
import pytest
from pydantic import ValidationError

from abacatepay.billings.models import (
    Billing,
    BillingIn,
    BillingList,
    BillingMetadata,
)


def test_billing_metadata_validate():
    data = {
        "completionUrl": "https://example.com/completion_url",
        "returnUrl": "https://example.com/return_url",
        "fee": 100,
    }
    bm = BillingMetadata.model_validate(data)

    assert (
        bm.completion_url == data["completionUrl"]
        and bm.return_url == data["returnUrl"]
        and bm.fee == data["fee"]
    )


def test_billing_metadata_dump_by_alias():
    expected_dump_result = {
        "completionUrl": "https://example.com/completion_url",
        "returnUrl": "https://example.com/return_url",
        "fee": 100,
    }
    dump_result = BillingMetadata(
        completion_url=expected_dump_result["completionUrl"],
        return_url=expected_dump_result["returnUrl"],
        fee=expected_dump_result["fee"],
    ).model_dump(by_alias=True)

    assert dump_result == expected_dump_result


def test_billing_list(billing_response_sample):
    data = [billing_response_sample]
    bl = BillingList(data=data)
    assert len(bl) == 1 and bl.data[0].id == billing_response_sample["id"]


def test_iterate_billing_list(billing_response_sample):
    billings = BillingList(data=[billing_response_sample])
    for billing in billings:
        assert billing == Billing(**billing_response_sample)


def test_billing_validate(billing_response_sample):
    result = Billing.model_validate(billing_response_sample)
    assert result.id == billing_response_sample["id"]


def test_billing_dump_by_alias(billing_response_sample):
    result = Billing(**billing_response_sample).model_dump(by_alias=True)
    assert_keys = [
        "id",
        "customer",
        "metadata",
        "products",
        "methods",
        "url",
        "coupons",
        "couponsUsed",
    ]
    assert all([result[k] == billing_response_sample[k] for k in assert_keys])


def test_billing_in_valid(one_product_sample, one_customer_metadata_sample):
    """Tests the creation of a valid BillingIn instance."""
    billing = BillingIn(
        frequency="ONE_TIME",
        methods=["PIX"],
        products=[one_product_sample],
        return_url="https://example.com/return",
        completion_url="https://example.com/completion",
        customer_id="cust_001",
        customer=one_customer_metadata_sample,
    )
    assert billing.frequency == "ONE_TIME"
    assert billing.methods == ["PIX"]
    assert billing.products[0] == one_product_sample
    assert str(billing.return_url) == "https://example.com/return"
    assert str(billing.completion_url) == "https://example.com/completion"
    assert billing.customer_id == "cust_001"
    assert billing.customer == one_customer_metadata_sample


def test_billing_in_missing_optional_fields(one_product_sample):
    """Tests the creation of a BillingIn instance without optional fields."""
    billing = BillingIn(
        frequency="ONE_TIME",
        methods=["PIX"],
        products=[one_product_sample],
        return_url="https://example.com/return",
        completion_url="https://example.com/completion",
    )
    assert billing.customer_id is None
    assert billing.customer == {}


def test_billing_in_invalid_url(one_product_sample):
    """Tests if invalid URLs raise a validation error."""
    with pytest.raises(ValidationError):
        BillingIn(
            frequency="ONE_TIME",
            methods=["PIX"],
            products=[one_product_sample],
            return_url="invalid_url",
            completion_url="invalid_url",
        )


def test_billing_in_serialization(one_product_sample):
    """Tests if serialization includes the correct aliases."""
    billing = BillingIn(
        frequency="ONE_TIME",
        methods=["PIX"],
        products=[one_product_sample],
        return_url="https://example.com/return",
        completion_url="https://example.com/completion",
        customer_id="cust_003",
    )
    serialized = billing.model_dump(by_alias=True)
    assert "returnUrl" in serialized
    assert "completionUrl" in serialized
    assert "customerId" in serialized
    assert str(serialized["returnUrl"]) == "https://example.com/return"
    assert str(serialized["completionUrl"]) == "https://example.com/completion"
    assert serialized["customerId"] == "cust_003"



================================================
FILE: tests/unit/coupons/test_coupons_models.py
================================================
from abacatepay.coupons.models import (Coupon,
                                       CouponIn)


def test_coupon_input_creation():
    """Tests the creation of a CouponIn instance and checks its attributes."""
    data = {
        "code": "DISCOUNT2025",
        "discount_kind": "PERCENTAGE",
        "discount": 20,
        "notes": "Special discount for loyal customers",
        "max_redeems": 100,
        "metadata": {"category": "loyalty"}
    }
    coupon_in = CouponIn(**data)
    assert coupon_in.code == data["code"]
    assert coupon_in.discount_kind == data["discount_kind"]
    assert coupon_in.discount == data["discount"]
    assert coupon_in.notes == data["notes"]
    assert coupon_in.max_redeems == data["max_redeems"]
    assert coupon_in.metadata == data["metadata"]


def test_coupon_creation():
    """Tests the creation of a Coupon instance and checks its attributes."""
    data = {
        "id": "coupon_12345",
        "discountKind": "FIXED_AMOUNT",
        "discount": 50,
        "status": "ACTIVE",
        "notes": "Holiday discount",
        "maxRedeems": 500,
        "redeemsCount": 100,
        "createdAt": "2025-05-01T12:00:00Z",
        "updatedAt": "2025-05-15T12:00:00Z",
        "devMode": True
    }
    coupon = Coupon(**data)
    assert coupon.id == data["id"]
    assert coupon.discount_kind == data["discountKind"]
    assert coupon.discount == data["discount"]
    assert coupon.status == data["status"]
    assert coupon.notes == data["notes"]
    assert coupon.max_redeems == data["maxRedeems"]
    assert coupon.redeems_count == data["redeemsCount"]
    assert coupon.created_at == data["createdAt"]
    assert coupon.updated_at == data["updatedAt"]
    assert coupon.dev_mode == data["devMode"]


def test_coupon_in_serialization():
    """Tests the serialization of a CouponIn instance."""
    data = {
        "code": "DISCOUNT2025",
        "discount_kind": "PERCENTAGE",
        "discount": 20,
        "notes": "Special discount for loyal customers",
        "max_redeems": 100,
        "metadata": {"category": "loyalty"}
    }
    coupon_in = CouponIn(**data)
    serialized = coupon_in.model_dump(by_alias=True)
    assert serialized == {
        "code": "DISCOUNT2025",
        "discountKind": "PERCENTAGE",
        "discount": 20,
        "notes": "Special discount for loyal customers",
        "maxRedeems": 100,
        "metadata": {"category": "loyalty"}
    }


================================================
FILE: tests/unit/customers/__init__.py
================================================



================================================
FILE: tests/unit/customers/test_customers_models.py
================================================
from abacatepay.customers.models import (
    CustomerMetadata, CustomerInline, Customer
)


def test_customer():
    """Tests the creation of a Customer instance and checks its attributes."""
    data = {
        'id': 'cust_xjf4iS21i1',
        "metadata": {
            "cellphone": "(99) 9999-9999",
            "email": "john@email.com",
            "name": "John Doe",
            "taxId": "445.665.140-72"
        }
    }
    cus = Customer(**data)
    assert cus.id == data["id"] 
    assert cus.metadata.tax_id == data["metadata"]["taxId"]

def test_customer_properties():
    """Tests if Customer properties correctly map to metadata values."""
    data = {
        'id': 'cust_xjf4iS21i1',
        "metadata": {
            "cellphone": "(99) 9999-9999",
            "email": "john@email.com",
            "name": "John Doe",
            "taxId": "445.665.140-72"
        }
    }
    cus = Customer(**data)
    assert cus.tax_id == "445.665.140-72"
    assert cus.cellphone == "(99) 9999-9999"
    assert cus.email == "john@email.com"
    assert cus.name == "John Doe"

def test_customer_inline_validation():
    """Tests if CustomerInline correctly handles metadata validation."""
    data = {
        "metadata": {
            "cellphone": "(99) 9999-9999",
            "email": "john@email.com",
            "name": "John Doe",
            "taxId": "445.665.140-72"
        }
    }
    cus = CustomerInline(**data)
    assert cus.metadata.tax_id == "445.665.140-72"

def test_customer_for_creation():
    """Tests the creation of a CustomerMetadata instance and its serialization."""
    data = {
        "cellphone": "(99) 9999-9999",
        "email": "john@email.com",
        "name": "John Doe",
        "taxId": "445.665.140-72"
    }
    cus = CustomerMetadata(**data)
    assert cus.tax_id == "445.665.140-72"
    dumped = cus.model_dump(by_alias=True)
    assert dumped == data



================================================
FILE: tests/unit/pixQrCode/test_qrcode_models.py
================================================
# Tests for abacatepay.pixQrCode.models

from abacatepay.pixQrCode.models import PixQrCode, PixStatus, PixQrCodeIn
from abacatepay.customers.models import CustomerMetadata

def test_pix_qrcode_creation():
    """Tests the creation of a PixQrCode instance and checks its attributes."""
    data = {
        "id": "pix_char_Gbg2XSFQmntL0Lzsb4SeL1zx",
        "amount": 1000,
        "status": "PENDING",
        "devMode": True,
        "brCode": "00020101021226820014br.gov.bcb.pix2560pix-h.asaas.com/qr/cobv/42f6026f-1cf4-4969-b168-ad77a3ae16e85204000053039865802BR5925PURPLE BOX TECNOLOGIA LTD6015Sao Jose dos Ca61081224600062070503***630418E5",
        "brCodeBase64": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPQAAAD0CAYAAACsLwv+AAAAAklEQVR4AewaftIAAA38SURBVO3B...",
        "platformFee": 80,
        "createdAt": "2025-05-28T19:24:45.884Z",
        "updatedAt": "2025-05-28T19:24:45.884Z",
        "expiresAt": "2025-05-29T19:24:45.883Z",
    }
    pix = PixQrCode(**data)
    assert pix.id == data["id"]
    assert pix.amount == data["amount"]
    assert pix.status == data["status"]
    assert pix.dev_mode == data["devMode"]
    assert pix.brcode == data["brCode"]
    assert pix.brcode_base64 == data["brCodeBase64"]
    assert pix.platform_fee == data["platformFee"]
    assert pix.created_at == data["createdAt"]
    assert pix.updated_at == data["updatedAt"]
    assert pix.expires_at == data["expiresAt"]

def test_pix_status_creation():
    """Tests the creation of a PixStatus instance and checks its attributes."""
    data = {
        "status": "PAID",
        "expires_at": "2025-05-29T19:45:03.256Z"
    }
    status = PixStatus(**data)
    assert status.status == data["status"]
    assert status.expires_at == data["expires_at"]

def test_pix_qrcode_in_creation_with_customer():
    """Tests the creation of a PixQrCodeIn instance with a CustomerMetadata."""
    customer = CustomerMetadata(
        tax_id="123.456.789-00",
        name="Test Customer",
        email="test@example.com",
        cellphone="(11) 99999-9999"
    )
    data = {
        "amount": 1500,
        "expires_in": 3600,
        "description": "Test payment",
        "customer": customer
    }
    pix_in = PixQrCodeIn(**data)
    assert pix_in.amount == data["amount"]
    assert pix_in.expires_in == data["expires_in"]
    assert pix_in.description == data["description"]
    assert isinstance(pix_in.customer, CustomerMetadata)
    assert pix_in.customer.tax_id == customer.tax_id

def test_pix_qrcode_in_creation_with_customer_dict():
    """Tests the creation of a PixQrCodeIn instance with a customer as dict."""
    customer_dict = {
        "tax_id": "123.456.789-00",
        "name": "Test Customer",
        "email": "test@example.com",
        "cellphone": "(11) 99999-9999"
    }
    data = {
        "amount": 2000,
        "expires_in": 1800,
        "description": "Another payment",
        "customer": customer_dict
    }
    pix_in = PixQrCodeIn(**data)
    assert pix_in.amount == data["amount"]
    assert pix_in.expires_in == data["expires_in"]
    assert pix_in.description == data["description"]
    assert isinstance(pix_in.customer, dict)
    assert pix_in.customer["tax_id"] == customer_dict["tax_id"]

def test_pix_qrcode_in_serialization():
    """Tests the serialization of a PixQrCodeIn instance."""
    data = {
        "amount": 500,
        "expires_in": 600,
        "description": "Serialize test",
        "customer": {
            "tax_id": "987.654.321-00",
            "name": "Serialize Customer",
            "email": "serialize@example.com",
            "cellphone": "(22) 88888-8888"
        }
    }
    pix_in = PixQrCodeIn(**data)
    serialized = pix_in.model_dump(by_alias=True)
    assert serialized["amount"] == 500
    assert serialized["expires_in"] == 600
    assert serialized["description"] == "Serialize test"
    assert serialized["customer"]["tax_id"] == "987.654.321-00"


================================================
FILE: tests/unit/products/__init__.py
================================================



================================================
FILE: tests/unit/products/test_products_models.py
================================================
import pytest
from pydantic import ValidationError

from abacatepay.products.models import Product, ProductInline


def test_valid_product():
    """Should initialize the product as expected"""
    product = Product(
        external_id="123",
        name="Test Product",
        description="A great product",
        quantity=2,
        price=150
    )
    assert product.external_id == "123"
    assert product.name == "Test Product"
    assert product.description == "A great product"
    assert product.quantity == 2
    assert product.price == 150


def test_product_missing_optional_description():
    """Should initialize even that description was not sent"""
    product = Product(
        external_id="123",
        name="Test Product",
        quantity=2,
        price=150
    )
    assert product.description is None


def test_product_invalid_quantity():
    """Should raise validation error when quantity less than 0"""
    with pytest.raises(ValidationError, match="Input should be greater than or equal to 1"):
        Product(external_id="123", name="Invalid Product", quantity=0, price=150)


def test_product_invalid_price():
    """Should raise validation error when price less than 100"""
    with pytest.raises(ValidationError, match="Input should be greater than or equal to 100"):
        Product(external_id="123", name="Invalid Product", quantity=1, price=99)


def test_product_alias_handling():
    """Should parse correctly the key `externalId`"""
    data = {"externalId": "456", "name": "Aliased Product", "quantity": 3, "price": 200}
    product = Product.model_validate(data)
    assert product.external_id == "456"


def test_product_serialization():
    """Should serialize in JS key format correctly as expected by API
    when by alias equals to True
    """
    product = Product(
        external_id="789",
        name="Serialized Product",
        quantity=1,
        price=1000
    )
    serialized = product.model_dump(by_alias=True)
    assert "externalId" in serialized
    assert serialized["externalId"] == "789"


def test_valid_product_inline():
    """Should serialize correctly"""
    product = ProductInline(
        id="prod_001",
        external_id="ext_123",
        quantity=5
    )
    assert product.id == "prod_001"
    assert product.external_id == "ext_123"
    assert product.quantity == 5


def test_product_inline_invalid_quantity():
    """Should raise validation error because quantity is less than 1"""
    with pytest.raises(ValidationError, match="Input should be greater than or equal to 1"):
        ProductInline(id="prod_002", external_id="ext_456", quantity=0)


def test_product_inline_alias_handling():
    """Should validate correctly the key external id in JS format"""
    data = {"id": "prod_003", "externalId": "ext_789", "quantity": 2}
    product = ProductInline.model_validate(data)
    assert product.external_id == "ext_789"


def test_product_inline_serialization():
    """Should serialize in the format expected by API when by alias equals True"""
    product = ProductInline(
        id="prod_004",
        external_id="ext_999",
        quantity=3
    )
    serialized = product.model_dump(by_alias=True)
    assert "externalId" in serialized
    assert serialized["externalId"] == "ext_999"



================================================
FILE: tests/unit/utils/__init__.py
================================================



================================================
FILE: tests/unit/utils/test_helpers.py
================================================
import pytest
from pydantic import ValidationError
from abacatepay.utils.helpers import prepare_data
from abacatepay.customers.models import CustomerMetadata


def test_prepare_data_with_model_instance(one_customer_metadata_sample):
    """Tests if prepare_data correctly serializes a BaseModel instance."""
    result = prepare_data(one_customer_metadata_sample, CustomerMetadata, use_alias=True)
    assert result["name"] == one_customer_metadata_sample.name
    assert result["email"] == one_customer_metadata_sample.email


def test_prepare_data_with_dict(one_customer_metadata_sample):
    """Tests if prepare_data correctly validates and serializes a dictionary."""
    data = one_customer_metadata_sample.model_dump()
    result = prepare_data(data, CustomerMetadata, use_alias=True)
    assert result["taxId"] == one_customer_metadata_sample.tax_id


def test_prepare_data_invalid_type():
    """Tests if prepare_data raises TypeError for invalid data types."""
    with pytest.raises(TypeError):
        prepare_data(123, CustomerMetadata)

def test_prepare_data_invalid_dict():
    """Tests if prepare_data raises ValidationError for an invalid dictionary."""
    invalid_data = {"invalid_field": "value"}  # Missing required fields
    with pytest.raises(ValidationError):
        prepare_data(invalid_data, CustomerMetadata)


